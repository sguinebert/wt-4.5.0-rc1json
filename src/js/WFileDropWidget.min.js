WT_DECLARE_WT_MEMBER(1,JavaScriptConstructor,"WFileDropWidget",function(k,b,t){b.wtLObj=this;var e=this,q="Wt-dropzone-hover",d=[],r=false,l=true,o=false,p=false,h=undefined,s=0,m=0,j=document.createElement("input");j.type="file";j.setAttribute("multiple","multiple");$(j).hide();b.appendChild(j);var i=document.createElement("div");$(i).addClass("Wt-dropcover");document.body.appendChild(i);this.eventContainsFile=function(a){var c=a.dataTransfer.types!=null&&a.dataTransfer.types.length>0&&a.dataTransfer.types[0]===
"Files";return a.dataTransfer.items!=null&&a.dataTransfer.items.length>0&&a.dataTransfer.items[0].kind==="file"||c};this.validFileCheck=function(a,c,g){var f=new FileReader;f.onload=function(){c(true,g)};f.onerror=function(){c(false,g)};f.readAsText(a.slice(0,32))};b.setAcceptDrops=function(a){l=a};b.setDropIndication=function(a){o=a};b.setDropForward=function(a){p=a};b.ondragenter=function(a){if(l){if(e.eventContainsFile(a)){m===0&&e.setPageHoverStyle();m=2;e.setWidgetHoverStyle(true)}a.stopPropagation()}};
b.ondragleave=function(a){var c=a.clientX;a=a.clientY;var g=document.elementFromPoint(c,a);if(c===0&&a===0)g=null;if(g===i){e.setWidgetHoverStyle(false);m=1}else e.resetDragDrop()};b.ondragover=function(a){a.preventDefault()};bodyDragEnter=function(){if((o||p)&&$(b).is(":visible")){m=1;e.setPageHoverStyle()}};document.body.addEventListener("dragenter",bodyDragEnter);i.ondragover=function(a){a.preventDefault();a.stopPropagation()};i.ondragleave=function(){!l||m!=1||e.resetDragDrop()};i.ondrop=function(a){let files=getDroppedOrSelectedFiles(a);console.log('files', files);a.preventDefault();
p?b.ondrop(a):e.resetDragDrop()};b.ondrop=async function(a){a.preventDefault();let fileList=await getDroppedOrSelectedFiles(a);if(l){e.resetDragDrop();window.FormData===undefined||fileList.length===0||e.addFiles(fileList)}};this.addFiles=function(a){for(var c=[],g=0;g<a.length;g++){var f={};f.id=Math.floor(Math.random()*Math.pow(2,31));f.file=a[g];d.push(f);var n={};n.id=f.id;n.filename=f.file.name;n.type=f.file.type;n.size=f.file.size;c.push(n)}k.emit(b,"dropsignal",JSON.stringify(c))};b.addEventListener("click",
function(){if(l){$(j).val("");j.click()}});b.markForSending=function(a){for(var c=0;c<a.length;c++)for(var g=a[c].id,f=0;f<d.length;f++)if(d[f].id===g){d[f].ready=true;break}r||d[0].ready&&e.requestSend()};this.requestSend=function(){if(d[0].skip)e.uploadFinished(null);else{r=true;k.emit(b,"requestsend",d[0].id)}};b.send=function(a,c){upload=d[0];if(upload.file.size>t){k.emit(b,"filetoolarge",upload.file.size);e.uploadFinished(null)}else e.validFileCheck(upload.file,h!=undefined&&c?e.workerSend:e.actualSend,
a)};this.actualSend=function(a,c){if(a){a=new XMLHttpRequest;a.addEventListener("load",e.uploadFinished);a.addEventListener("error",e.uploadFinished);a.addEventListener("abort",e.uploadFinished);a.addEventListener("timeout",e.uploadFinished);a.open("POST",c);d[0].request=a;c=new FormData;c.append("file-id",d[0].id);c.append("data",d[0].file);a.send(c)}else e.uploadFinished(null)};this.workerSend=function(a,c){if(a){h.upload=d[0];h.postMessage({cmd:"send",url:c,upload:d[0],chunksize:s})}else e.uploadFinished(null)};
this.uploadFinished=function(a){if(a!=null&&a.type==="load"&&a.currentTarget.status===200||a===true)k.emit(b,"uploadfinished",d[0].id);d.splice(0,1);if(d[0]&&d[0].ready)e.requestSend();else{r=false;k.emit(b,"donesending")}};b.cancelUpload=function(a){if(d[0]&&d[0].id===a){d[0].skip=true;if(d[0].request)d[0].request.abort();else h&&h.upload===d[0]&&h.postMessage({cmd:"cancel",upload:d[0]})}else for(var c=1;c<d.length;c++)if(d[c].id===a)d[c].skip=true};j.onchange=function(){if(l)window.FormData===undefined||
this.files===null||this.files.length===0||e.addFiles(this.files)};this.setPageHoverStyle=function(){if(o||p){$(i).addClass("Wt-dropzone-dragstyle");$(b).addClass("Wt-dropzone-dragstyle");o&&$(b).addClass("Wt-dropzone-indication")}};this.setWidgetHoverStyle=function(a){a?$(b).addClass(q):$(b).removeClass(q)};this.resetDragDrop=function(){$(b).removeClass("Wt-dropzone-indication");$(b).removeClass("Wt-dropzone-dragstyle");$(i).removeClass("Wt-dropzone-dragstyle");e.setWidgetHoverStyle(false);m=0};b.configureHoverClass=
function(a){q=a};b.setFilters=function(a){j.setAttribute("accept",a)};b.setUploadWorker=function(a){if(a&&window.Worker){h=new Worker(a);h.onmessage=function(c){if(c.data.workerfeatures){if(c.data.workerfeatures!=="valid"){b.setUploadWorker(null);k.emit(b,"filternotsupported")}}else e.uploadFinished(c.data)};h.postMessage({cmd:"check"})}else h=undefined};b.setChunkSize=function(a){s=a};b.destructor=function(){document.body.removeEventListener("dragenter",bodyDragEnter);document.body.removeChild(i)};


    function traverseDirectory(entry) {
      const reader = entry.createReader();
      // Resolved when the entire directory is traversed
      return new Promise((resolveDirectory) => {
        const iterationAttempts = [];
        const errorHandler = () => {};
        function readEntries() {
          // According to the FileSystem API spec, readEntries() must be called until
          // it calls the callback with an empty array.
          reader.readEntries((batchEntries) => {
            if (!batchEntries.length) {
              // Done iterating this particular directory
              resolveDirectory(Promise.all(iterationAttempts));
            } else {
              // Add a list of promises for each directory entry.  If the entry is itself
              // a directory, then that promise won't resolve until it is fully traversed.
              iterationAttempts.push(Promise.all(batchEntries.map((batchEntry) => {
                if (batchEntry.isDirectory) {
                  return traverseDirectory(batchEntry);
                }
                return Promise.resolve(batchEntry);
              })));
              // Try calling readEntries() again for the same dir, according to spec
              readEntries();
            }
          }, errorHandler);
        }
        // initial call to recursive entry reader function
        readEntries();
      });
    }

    function getFile(entry) {
      return new Promise((resolve) => {
        entry.file((file) => {
          resolve(file, entry);
        });
      });
    }

    function handleFilePromises(promises, fileList) {
      return Promise.all(promises).then((files) => {
        files.forEach((file) => {
            fileList.push(file);
        });
        return fileList;
      });
    };
    function getDataTransferFiles(dataTransfer) {
      const dataTransferFiles = [];
      const folderPromises = [];
      const filePromises = [];

      [].slice.call(dataTransfer.items).forEach((listItem) => {
        if (typeof listItem.webkitGetAsEntry === 'function') {
          const entry = listItem.webkitGetAsEntry();

          if (entry) {
            if (entry.isDirectory) {
              folderPromises.push(traverseDirectory(entry));
            } else {
              filePromises.push(getFile(entry));
            }
          }
        } else {
          dataTransferFiles.push(listItem);
        }
      });
      if (folderPromises.length) {
        const flatten = (array) => array.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
        return Promise.all(folderPromises).then((fileEntries) => {
          const flattenedEntries = flatten(fileEntries);
          // collect async promises to convert each fileEntry into a File object
          flattenedEntries.forEach((fileEntry) => {
            filePromises.push(getFile(fileEntry));
          });
          return handleFilePromises(filePromises, dataTransferFiles);
        });
      } else if (filePromises.length) {
        return handleFilePromises(filePromises, dataTransferFiles);
      }
      return Promise.resolve(dataTransferFiles);
    };

    function getDroppedOrSelectedFiles(event) {
      const dataTransfer = event.dataTransfer;
      if (dataTransfer && dataTransfer.items) {
        return getDataTransferFiles(dataTransfer).then((fileList) => {
          return Promise.resolve(fileList);
        });
      }
      const files = [];
      const dragDropFileList = dataTransfer && dataTransfer.files;
      const inputFieldFileList = event.target && event.target.files;
      const fileList = dragDropFileList || inputFieldFileList || [];
      // convert the FileList to a simple array of File objects
      for (let i = 0; i < fileList.length; i++) {
        files.push(packageFile(fileList[i]));
      }
      return Promise.resolve(files);
    };

});
